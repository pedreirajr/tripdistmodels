---
output:
  github_document:
    html_preview: false
---

# tripdistmodels: An R package for trip distribution models <img src="man/figures/hex_tripdistmodels.png" align="right" width="190"/>

[![R-CMD-check](https://github.com/pedreirajr/tripdistmodels/actions/workflows/R-CMD-check.yaml/badge.svg)](https://github.com/pedreirajr/tripdistmodels/actions/workflows/R-CMD-check.yaml) [![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](LICENSE.md) [![Lifecycle: experimental](https://img.shields.io/badge/lifecycle-experimental-orange.svg)](https://lifecycle.r-lib.org/articles/stages.html#experimental)

### Current scope

**tripdistmodels** currently provides two core building blocks for trip distribution work:

-   **Furness balancing (Iterative Proportional Fitting, IPF)** to adjust a seed OD so row and column totals match target productions and attractions.
-   **Doubly constrained gravity modeling** to synthesize an OD matrix given targets and a cost matrix, with calibration of deterrence parameters using **Poisson maximum likelihood** (and optional Hyman calibration for the exponential form).

Inputs can be provided as **square matrices** or as **long tables** (origin, destination, value). Functions return diagnostics to help validate balancing and calibration.

## Installation

Install the development version using **pak**:

``` r
pak::pak("pedreirajr/tripdistmodels")
```

Then load it:

``` r
library(tripdistmodels)
```

## What the package does

### 1) Furness (IPF) balancing

Use `furness()` when you have a seed OD (base or synthetic) and you want it to match target margins:

-   `o_target`: target productions (row totals)
-   `d_target`: target attractions (column totals)

If `sum(o_target)` differs from `sum(d_target)`, `scale_totals` controls how totals are reconciled:

-   `"d_to_o"` rescales `d_target` to match `sum(o_target)`
-   `"o_to_d"` rescales `o_target` to match `sum(d_target)`

The algorithm alternates row and column scaling until convergence.

### 2) Gravity model synthesis with calibration

Use `gravit()` to synthesize an OD matrix under a doubly constrained gravity structure:

-   You provide a base OD (matrix or table), a cost matrix (matrix or table), and optional targets.
-   Deterrence parameters are calibrated to the base OD using Poisson maximum likelihood, while enforcing current marginals internally via IPF.

Supported deterrence functions:

-   Exponential: $f(c) = \exp(-\beta c)$, with $\beta > 0$
-   Power: $f(c) = c^{-n}$, with $n > 0$
-   Combined: $f(c) = \exp(-\beta c)\,c^{-n}$, with $\beta > 0$ and $n > 0$

Notes:

-   For `"power"` and `"combined"`, a positive cost floor can be applied to handle zero or non-positive costs (`c_floor` or `c_floor_rate`).
-   Missing OD pairs can be treated as unobserved (`missing = "exclude"`, default) or as observed zeros (`missing = "zero"`).

## Estimation and calibration

`gravit()` supports three estimation modes via `estimation`:

-   `"poisson"` (default): estimates deterrence parameters by maximizing a Poisson log-linear likelihood.
-   `"hyman"`: available only for `deterrence = "exp"`, calibrates $\beta$ to match observed and modeled mean cost.
-   `"fixed"`: no calibration, uses user-provided `beta` and/or `n`.

### How Poisson maximum likelihood works

For each candidate parameter vector (for example, `beta` in the exponential case or `(beta, n)` in the combined case), `gravit()` evaluates an objective based on the Poisson log-likelihood.

Conceptually, each objective evaluation does:

1.  Compute current marginals from the base OD (with `missing` handling applied):
    -   $O_{now}$ are row sums
    -   $D_{now}$ are column sums
2.  Build a gravity seed matrix using these marginals and the current deterrence parameters:
    -   $seed_{ij} = O_{now,i}\,D_{now,j}\,f(c_{ij};\theta)$
3.  Run IPF (Furness) to balance the seed exactly to $O_{now}$ and $D_{now}$, producing $\mu_{ij}$.
4.  Evaluate the Poisson log-likelihood on observed cells only (when `missing = "exclude"`) or on all cells (when `missing = "zero"`), ignoring the $\log(y!)$ constants:
    -   $\ell(\theta) = \sum (y_{ij}\log \mu_{ij} - \mu_{ij})$
5.  Use numerical optimization (L-BFGS-B with non-negativity bounds) to find parameters that maximize $\ell(\theta)$.

After parameters are estimated, `gravit()` runs a final synthesis step:

-   It builds a seed using the requested targets `o_target` and `d_target`, and balances that seed to those targets via IPF to produce the final `od_model`.

Practical note: in the combined form, `beta` and `n` can trade off depending on the cost distribution (partial confounding). If you see unstable estimates, consider `"fixed"` for one parameter, or rescale costs to keep `beta * cost` in a reasonable range.

### How the Hyman procedure works (exp only)

When `estimation = "hyman"` and `deterrence = "exp"`, the calibration targets the mean travel cost:

1.  Compute the observed mean cost (weighted by observed trips on observed cells).
2.  Initialize $\beta$ (often using $1 / \bar{c}$).
3.  Iterate: given $\beta$, build a seed, balance it to current marginals, compute modeled mean cost, and update $\beta$ so the modeled mean cost moves toward the observed mean cost.

This is a classic calibration heuristic for exponential gravity models.

## Inputs and formats

### OD input

You can provide `od` (for `furness()`) or `od_base` (for `gravit()`) as:

-   **Matrix**: numeric square matrix with identical row and column names (zones).
-   **Table**: long `data.frame` with origin, destination, and trips columns.

For table OD input: - Only OD pairs present in the table are filled. - Missing pairs become `NA` in the reconstructed matrix and are handled according to `missing`.

Default table column names are: - origin: `ori` (override with `o_col`) - destination: `des` (override with `d_col`) - trips: `n` (override with `t_col`)

### Cost input

You can provide `cost` as:

-   **Matrix**: numeric square matrix aligned to the OD zoning.
-   **Table**: long `data.frame` with origin, destination, and cost columns.

Default table column names are: - origin: `ori` (override with `o_col`) - destination: `des` (override with `d_col`) - cost: `c` (override with `c_col`)

For table cost input, full coverage is recommended so the cost matrix can be rebuilt without gaps.

## Quick examples

### Example A: Furness balancing with matrix input

``` r
library(tripdistmodels)

set.seed(1)
zones <- LETTERS[1:4]

seed <- matrix(runif(16, 1, 10), nrow = 4, dimnames = list(zones, zones))

o_target <- c(A = 140, B = 85, C = 55, D = 50)
d_target <- c(A = 100, B = 80, C = 85, D = 65)

fit <- furness(
  od = seed,
  od_type = "matrix",
  o_target = o_target,
  d_target = d_target,
  scale_totals = "d_to_o",
  tol = 1e-8,
  max_iter = 5000,
  verbose = FALSE
)

# Balanced OD
fit$od_balanced

# Check margins
max(abs(rowSums(fit$od_balanced) - fit$o_target))
max(abs(colSums(fit$od_balanced) - fit$d_target))
```

### Example B: Gravity synthesis with matrix inputs (exp + Poisson ML)

``` r
library(tripdistmodels)

set.seed(2)
zones <- paste0("Z", 1:6)

xy <- cbind(runif(6), runif(6))
cost <- as.matrix(dist(xy)) * 100
dimnames(cost) <- list(zones, zones)

# Base OD (with some zeros)
od_base <- matrix(rpois(36, lambda = 10), 6, 6, dimnames = list(zones, zones))

# Targets (here, use base marginals)
o_target <- rowSums(od_base, na.rm = TRUE)
d_target <- colSums(od_base, na.rm = TRUE)

res <- gravit(
  od_base = od_base,
  cost = cost,
  od_type = "matrix",
  cost_type = "matrix",
  deterrence = "exp",
  estimation = "poisson",
  missing = "exclude",
  o_target = o_target,
  d_target = d_target,
  scale_totals = "d_to_o",
  tol = 1e-6,
  max_iter = 2000,
  verbose = TRUE
)

res$params
res$converged

# Check margins
max(abs(rowSums(res$od_model) - res$o_target))
max(abs(colSums(res$od_model) - res$d_target))
```

### Example C: Gravity synthesis with table inputs and custom column names

``` r
library(tripdistmodels)

set.seed(3)
zones <- c("A", "B", "C", "D")

# OD table
od_tab <- data.frame(
  o = c("A","A","B","B","C","D"),
  d = c("B","C","C","D","D","A"),
  t = c(30, 20, 10, 15, 8, 12)
)

# Cost table
grid <- expand.grid(o = zones, d = zones, stringsAsFactors = FALSE)
cost_mat <- matrix(
  c(0,  5, 10, 18,
    5,  0,  7, 14,
   10,  7,  0,  9,
   18, 14,  9,  0),
  nrow = 4, byrow = TRUE, dimnames = list(zones, zones)
)
cost_tab <- transform(grid, c = as.numeric(cost_mat[cbind(match(o, zones), match(d, zones))]))

# Targets (example)
o_target <- c(A = 140, B = 85, C = 55, D = 50)
d_target <- c(A = 100, B = 80, C = 85, D = 65)

res <- gravit(
  od_base = od_tab,
  cost = cost_tab,
  od_type = "table",
  cost_type = "table",
  deterrence = "combined",
  estimation = "poisson",
  missing = "exclude",
  o_target = o_target,
  d_target = d_target,
  o_col = "o",
  d_col = "d",
  t_col = "t",
  c_col = "c",
  c_floor = 1.0,
  scale_totals = "d_to_o",
  verbose = FALSE
)

res$params
```

## Outputs and diagnostics

### `furness()`

Returns a list with:

-   `od_balanced`: balanced OD matrix
-   `converged`: logical
-   `iterations`: number of iterations used
-   `max_rel_error`: final maximum relative marginal error
-   `o_target`, `d_target`: the targets used after any rescaling

### `gravit()`

Returns a list with:

-   `od_base`: base OD matrix (as provided or reconstructed from table)
-   `cost`: cost matrix (as provided or reconstructed from table)
-   `od_model`: final synthesized OD matrix
-   `deterrence`, `estimation`, `missing`
-   `params`: estimated parameters (`beta`, `n`, depending on the deterrence)
-   `converged`, `iterations`, `max_rel_error`
-   `o_target`, `d_target`: targets used after any rescaling

## Practical tips

-   Start with a looser tolerance while iterating on inputs and diagnostics (for example `tol = 1e-4`), then tighten once results look stable.
-   For `"power"` and `"combined"`, be mindful of zero costs. Use `c_floor` (scalar or per-origin vector) or leave `c_floor = NULL` and control `c_floor_rate`.
-   For `"combined"`, `beta` and `n` can be partially confounded depending on the cost distribution. If estimation is unstable, consider fixing one parameter (`estimation = "fixed"`) and estimating the other via external calibration.

## Roadmap

Planned enhancements include:

-   Additional calibration objectives and diagnostic summaries.
-   Intervening opportunities models.

## Citation

If you use **tripdistmodels** in academic work, consider citing the package repository and the specific release or commit you used.
